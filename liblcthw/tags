!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
ByteOf	src/lcthw/radixmap.c	38;"	d	file:
CFLAGS	Makefile	/^CFLAGS=-g -O2 -Wall -Wextra -Isrc $(shell pkg-config --cflags libbsd) -rdynamic -DNDEBUG $(OPTFLAGS)$/;"	m
CFLAGS	Makefile	/^dev: CFLAGS=-g -O2 -Wall -Wextra -Isrc $(shell pkg-config --cflags libbsd) $(OPTFLAGS)$/;"	m
COMMON_LIBS	Makefile	/^COMMON_LIBS = $(shell pkg-config --libs libbsd) -ldl $(OPTLIBS)$/;"	m
DArray	src/lcthw/darray.h	/^typedef struct DArray{$/;"	s
DArray	src/lcthw/darray.h	/^} DArray;$/;"	t	typeref:struct:DArray
DArray_clear	src/lcthw/darray.c	/^void DArray_clear(DArray *array){$/;"	f
DArray_clear_destroy	src/lcthw/darray.c	/^void DArray_clear_destroy(DArray * array){$/;"	f
DArray_compare	src/lcthw/darray_algos.h	/^typedef int (*DArray_compare)(const void *a,const void *b);$/;"	t
DArray_contract	src/lcthw/darray.c	/^int DArray_contract(DArray * array){$/;"	f
DArray_count	src/lcthw/darray.h	37;"	d
DArray_create	src/lcthw/darray.c	/^DArray *DArray_create(size_t element_size,size_t inital_max){$/;"	f
DArray_destroy	src/lcthw/darray.c	/^void DArray_destroy(DArray * array){$/;"	f
DArray_end	src/lcthw/darray.h	36;"	d
DArray_expand	src/lcthw/darray.c	/^int DArray_expand(DArray * array){$/;"	f
DArray_first	src/lcthw/darray.h	35;"	d
DArray_free	src/lcthw/darray.h	90;"	d
DArray_get	src/lcthw/darray.h	/^static inline void *DArray_get(DArray * array, int i){$/;"	f
DArray_heapsort	src/lcthw/darray_algos.c	/^int DArray_heapsort(DArray * array, DArray_compare cmp){$/;"	f
DArray_last	src/lcthw/darray.h	34;"	d
DArray_max	src/lcthw/darray.h	38;"	d
DArray_mergesort	src/lcthw/darray_algos.c	/^int DArray_mergesort(DArray * array, DArray_compare cmp){$/;"	f
DArray_new	src/lcthw/darray.h	/^static inline void *DArray_new(DArray * array){$/;"	f
DArray_pop	src/lcthw/darray.c	/^void *DArray_pop(DArray * array){$/;"	f
DArray_push	src/lcthw/darray.c	/^int DArray_push(DArray * array, void *el){$/;"	f
DArray_qsort	src/lcthw/darray_algos.c	/^int DArray_qsort(DArray * array, DArray_compare cmp){$/;"	f
DArray_remove	src/lcthw/darray.h	/^static inline void *DArray_remove(DArray * array,int i){$/;"	f
DArray_resize	src/lcthw/darray.c	/^static inline int DArray_resize(DArray * array, size_t new_size){$/;"	f	file:
DArray_set	src/lcthw/darray.h	/^static inline void DArray_set(DArray * array,int i, void *el){$/;"	f
DEFAULT_EXPAND_RATE	src/lcthw/darray.h	40;"	d
LDFLAGS	Makefile	/^LDFLAGS=$(OPTLIBS)$/;"	m
LDLIBS	Makefile	/^LDLIBS=$(COMMON_LIBS)$/;"	m
LDLIBS	Makefile	/^tests: LDLIBS = $(TARGET) $(COMMON_LIBS)$/;"	m
LIST_FOREACH	src/lcthw/list.h	73;"	d
List	src/lcthw/list.h	/^typedef struct List{$/;"	s
List	src/lcthw/list.h	/^} List;$/;"	t	typeref:struct:List
ListNode	src/lcthw/list.h	/^typedef struct ListNode{$/;"	s
ListNode	src/lcthw/list.h	/^} ListNode;$/;"	t	typeref:struct:ListNode
List_bubble_sort	src/lcthw/list_algos.c	/^int List_bubble_sort(List *words,List_compare cmp){$/;"	f
List_compare	src/lcthw/list_algos.h	/^typedef int (*List_compare)(const void *a,const void *b);$/;"	t
List_copy	src/lcthw/list.c	/^void List_copy(List *to, List *from){$/;"	f
List_count	src/lcthw/list.h	35;"	d
List_create	src/lcthw/list.c	/^List *List_create(){$/;"	f
List_destroy	src/lcthw/list.c	/^void List_destroy(List *list){$/;"	f
List_first	src/lcthw/list.h	36;"	d
List_insert	src/lcthw/list.c	/^void List_insert(List *list,ListNode *cur,void *value){$/;"	f
List_insert_index	src/lcthw/list.c	/^void List_insert_index(List *list,size_t index,void *value){$/;"	f
List_insert_sort	src/lcthw/list_algos.c	/^int List_insert_sort(List *words,void *value,List_compare cmp){$/;"	f
List_join	src/lcthw/list.c	/^void List_join(List *list_1,List *list_2){$/;"	f
List_last	src/lcthw/list.h	37;"	d
List_merge	src/lcthw/list_algos.c	/^inline List *List_merge(List *left, List *right,List_compare cmp){$/;"	f
List_merge_sort	src/lcthw/list_algos.c	/^List *List_merge_sort(List *words, List_compare cmp){$/;"	f
List_pop	src/lcthw/list.c	/^void *List_pop(List *list){$/;"	f
List_push	src/lcthw/list.c	/^void List_push(List *list, void *value){$/;"	f
List_remove	src/lcthw/list.c	/^void *List_remove(List *list,ListNode *node){$/;"	f
List_shift	src/lcthw/list.c	/^void *List_shift(List *list){$/;"	f
List_split	src/lcthw/list.c	/^void List_split(List *list,List *list_1,List *list_2){$/;"	f
List_swap	src/lcthw/list_algos.c	/^void List_swap(ListNode *node_1,ListNode *node_2){$/;"	f
List_unshift	src/lcthw/list.c	/^void List_unshift(List *list,void *value){$/;"	f
List_values	src/lcthw/list.c	/^void List_values(List *list){$/;"	f
NDEBUG	tests/minunit.h	1;"	d
NDEBUG	tests/timer.h	1;"	d
NUM_VALUES	tests/list_algos_tests.c	9;"	d	file:
Node_create	src/lcthw/list.c	/^ListNode *Node_create(){$/;"	f
OBJECTS	Makefile	/^OBJECTS=$(patsubst %.c,%.o,$(SOURCES))$/;"	m
PREFIX	Makefile	/^PREFIX?=\/usr\/local$/;"	m
RMElement	src/lcthw/radixmap.h	/^typedef union RMElement{$/;"	u
RMElement	src/lcthw/radixmap.h	/^} RMElement;$/;"	t	typeref:union:RMElement
RUN_TESTS	tests/minunit.h	17;"	d
RadixMap	src/lcthw/radixmap.h	/^typedef struct RadixMap{$/;"	s
RadixMap	src/lcthw/radixmap.h	/^} RadixMap;$/;"	t	typeref:struct:RadixMap
RadixMap_add	src/lcthw/radixmap.c	/^int RadixMap_add(RadixMap * map,uint32_t key, uint32_t value){$/;"	f
RadixMap_bisect	src/lcthw/radixmap.c	/^int RadixMap_bisect(RadixMap * map, uint32_t key){$/;"	f
RadixMap_create	src/lcthw/radixmap.c	/^RadixMap *RadixMap_create(size_t max){$/;"	f
RadixMap_delete	src/lcthw/radixmap.c	/^int RadixMap_delete(RadixMap * map, RMElement * el){$/;"	f
RadixMap_destroy	src/lcthw/radixmap.c	/^void RadixMap_destroy(RadixMap * map){$/;"	f
RadixMap_find	src/lcthw/radixmap.c	/^RMElement *RadixMap_find(RadixMap * map, uint32_t to_find){$/;"	f
RadixMap_merge	src/lcthw/radixmap.c	/^static inline RadixMap *RadixMap_merge(RadixMap * left,RadixMap * right){$/;"	f	file:
RadixMap_mergesort	src/lcthw/radixmap.c	/^RadixMap * RadixMap_mergesort(RadixMap * map){$/;"	f
RadixMap_quicksort	src/lcthw/radixmap.c	/^RadixMap * RadixMap_quicksort(RadixMap * map,int low, int high){$/;"	f
RadixMap_sort	src/lcthw/radixmap.c	/^void RadixMap_sort(RadixMap * map, int position){$/;"	f
SOURCES	Makefile	/^SOURCES=$(wildcard src\/**\/*.c src\/*.c)$/;"	m
SO_TARGET	Makefile	/^SO_TARGET=$(patsubst %.a,%.so,$(TARGET))$/;"	m
TARGET	Makefile	/^TARGET=build\/liblcthw.a$/;"	m
TESTS	Makefile	/^TESTS=$(patsubst %.c,%,$(TEST_SRC))$/;"	m
TEST_SRC	Makefile	/^TEST_SRC=$(wildcard tests\/*_tests.c)$/;"	m
_Darray_h	src/lcthw/darray.h	2;"	d
__dbg_h__	src/lcthw/dbg.h	2;"	d
_minunit_h_	tests/minunit.h	3;"	d
_radixmap_h	src/lcthw/radixmap.h	2;"	d
_timer_h	tests/timer.h	3;"	d
all_tests	tests/darray_algos_tests.c	/^RUN_TESTS(all_tests);$/;"	v
all_tests	tests/darray_algos_tests.c	/^char *all_tests(){$/;"	f
all_tests	tests/darray_tests.c	/^RUN_TESTS(all_tests);$/;"	v
all_tests	tests/darray_tests.c	/^char *all_tests(){$/;"	f
all_tests	tests/list_algos_tests.c	/^RUN_TESTS(all_tests);$/;"	v
all_tests	tests/list_algos_tests.c	/^char *all_tests(){$/;"	f
all_tests	tests/list_tests.c	/^char *all_tests(){$/;"	f
all_tests	tests/radixmap_tests.c	/^RUN_TESTS(all_tests);$/;"	v
all_tests	tests/radixmap_tests.c	/^char *all_tests(){$/;"	f
array	tests/darray_tests.c	/^static DArray *array = NULL;$/;"	v	file:
check	src/lcthw/dbg.h	28;"	d
check_debug	src/lcthw/dbg.h	36;"	d
check_mem	src/lcthw/dbg.h	34;"	d
check_order	tests/radixmap_tests.c	/^static int check_order(RadixMap * map){$/;"	f	file:
clean_errno	src/lcthw/dbg.h	15;"	d
contents	src/lcthw/darray.h	/^  void **contents;$/;"	m	struct:DArray
contents	src/lcthw/radixmap.h	/^  RMElement *contents;$/;"	m	struct:RadixMap
count	src/lcthw/list.h	/^  int count;$/;"	m	struct:List
counter	src/lcthw/radixmap.h	/^  uint32_t counter;$/;"	m	struct:RadixMap
create_words	tests/darray_algos_tests.c	/^DArray *create_words(){$/;"	f
create_words	tests/list_algos_tests.c	/^List *create_words(){$/;"	f
data	src/lcthw/radixmap.h	/^  } data;$/;"	m	union:RMElement	typeref:struct:RMElement::__anon1
debug	src/lcthw/dbg.h	11;"	d
debug	src/lcthw/dbg.h	9;"	d
element_size	src/lcthw/darray.h	/^  size_t element_size;$/;"	m	struct:DArray
end	src/lcthw/darray.h	/^  int end;$/;"	m	struct:DArray
end	src/lcthw/radixmap.h	/^  size_t end;$/;"	m	struct:RadixMap
end	tests/darray_algos_tests.c	/^static clock_t start,end;$/;"	v	file:
end	tests/radixmap_tests.c	/^static clock_t start, end;$/;"	v	file:
expand_rate	src/lcthw/darray.h	/^  size_t expand_rate;$/;"	m	struct:DArray
first	src/lcthw/list.h	/^  ListNode *first;$/;"	m	struct:List
getKey	src/lcthw/radixmap.h	22;"	d
is_sorted	tests/darray_algos_tests.c	/^int is_sorted(DArray *array){$/;"	f
is_sorted	tests/list_algos_tests.c	/^int is_sorted(List *words){$/;"	f
key	src/lcthw/radixmap.h	/^    uint32_t key;$/;"	m	struct:RMElement::__anon1
last	src/lcthw/list.h	/^  ListNode *last;$/;"	m	struct:List
lcthw_List_h	src/lcthw/list.h	2;"	d
lcthw_darray_algos_h	src/lcthw/darray_algos.h	2;"	d
lcthw_list_algos_h	src/lcthw/list_algos.h	2;"	d
list	tests/list_tests.c	/^static List *list = NULL;$/;"	v	file:
list_2	tests/list_tests.c	/^static List *list_2 = NULL;$/;"	v	file:
list_3	tests/list_tests.c	/^static List *list_3 = NULL;$/;"	v	file:
list_4	tests/list_tests.c	/^static List *list_4 = NULL;$/;"	v	file:
list_5	tests/list_tests.c	/^static List *list_5 = NULL;$/;"	v	file:
log_err	src/lcthw/dbg.h	17;"	d
log_info	src/lcthw/dbg.h	25;"	d
log_warn	src/lcthw/dbg.h	21;"	d
make_random	tests/radixmap_tests.c	/^static int make_random(RadixMap * map){$/;"	f	file:
max	src/lcthw/darray.h	/^  int max;$/;"	m	struct:DArray
max	src/lcthw/radixmap.h	/^  size_t max;$/;"	m	struct:RadixMap
mu_assert	tests/minunit.h	11;"	d
mu_run_test	tests/minunit.h	14;"	d
mu_suite_start	tests/minunit.h	9;"	d
next	src/lcthw/list.h	/^  struct ListNode *next;$/;"	m	struct:ListNode	typeref:struct:ListNode::ListNode
partition	src/lcthw/radixmap.c	/^int partition(RadixMap * map,int * low, int * high){$/;"	f
prev	src/lcthw/list.h	/^  struct ListNode *prev;$/;"	m	struct:ListNode	typeref:struct:ListNode::ListNode
print_map	tests/radixmap_tests.c	/^static void print_map(RadixMap * map){$/;"	f	file:
radix_sort	src/lcthw/radixmap.c	/^static inline void radix_sort(short offset, uint64_t max, uint64_t * source, uint64_t * dest){$/;"	f	file:
raw	src/lcthw/radixmap.h	/^  uint64_t raw;$/;"	m	union:RMElement
run_sort_test	tests/darray_algos_tests.c	/^char *run_sort_test(int (*sort_func)(DArray *,DArray_compare),const char *name){$/;"	f
sentinel	src/lcthw/dbg.h	31;"	d
start	tests/darray_algos_tests.c	/^static clock_t start,end;$/;"	v	file:
start	tests/radixmap_tests.c	/^static clock_t start, end;$/;"	v	file:
string_compare	tests/list_tests.c	/^static inline int string_compare(char *string1, char *string2){$/;"	f	file:
temp	src/lcthw/radixmap.h	/^  RMElement *temp;$/;"	m	struct:RadixMap
test1	tests/list_tests.c	/^char *test1 = "test1 data";$/;"	v
test2	tests/list_tests.c	/^char *test2 = "test2 data";$/;"	v
test3	tests/list_tests.c	/^char *test3 = "test3 data";$/;"	v
test_bubble_sort	tests/list_algos_tests.c	/^char *test_bubble_sort(){$/;"	f
test_copy	tests/list_tests.c	/^char *test_copy(){$/;"	f
test_create	tests/darray_tests.c	/^char *test_create(){$/;"	f
test_create	tests/list_tests.c	/^char *test_create(){$/;"	f
test_destroy	tests/darray_tests.c	/^char *test_destroy(){$/;"	f
test_destroy	tests/list_tests.c	/^char *test_destroy(){$/;"	f
test_expand_contract	tests/darray_tests.c	/^char *test_expand_contract(){$/;"	f
test_find	tests/radixmap_tests.c	/^static int test_find(RadixMap * map){$/;"	f	file:
test_get	tests/darray_tests.c	/^char *test_get(){$/;"	f
test_heapsort	tests/darray_algos_tests.c	/^char *test_heapsort(){$/;"	f
test_insert	tests/list_tests.c	/^char *test_insert(){$/;"	f
test_insert_sort	tests/list_algos_tests.c	/^char *test_insert_sort(){$/;"	f
test_join	tests/list_tests.c	/^char *test_join(){$/;"	f
test_merge_sort	tests/list_algos_tests.c	/^char *test_merge_sort(){$/;"	f
test_mergesort	tests/darray_algos_tests.c	/^char *test_mergesort(){$/;"	f
test_new	tests/darray_tests.c	/^char *test_new(){$/;"	f
test_operations	tests/radixmap_tests.c	/^static char *test_operations(){$/;"	f	file:
test_push_pop	tests/darray_tests.c	/^char *test_push_pop(){$/;"	f
test_push_pop	tests/list_tests.c	/^char *test_push_pop(){$/;"	f
test_qsort	tests/darray_algos_tests.c	/^char *test_qsort(){$/;"	f
test_remove	tests/darray_tests.c	/^char *test_remove(){$/;"	f
test_remove	tests/list_tests.c	/^char *test_remove(){$/;"	f
test_set	tests/darray_tests.c	/^char *test_set(){$/;"	f
test_shift	tests/list_tests.c	/^char *test_shift(){$/;"	f
test_split	tests/list_tests.c	/^char *test_split(){$/;"	f
test_unshift	tests/list_tests.c	/^char *test_unshift(){$/;"	f
test_values	tests/list_tests.c	/^char *test_values(){$/;"	f
testcmp	tests/darray_algos_tests.c	/^int testcmp(char **a, char **b){$/;"	f
tests_run	tests/minunit.h	/^int tests_run;$/;"	v
timer_end	tests/timer.h	/^static inline void timer_end(clock_t * start, clock_t * end, char * message){$/;"	f
timer_start	tests/timer.h	/^static inline void timer_start(clock_t *start){$/;"	f
val1	tests/darray_tests.c	/^static int *val1 = NULL;$/;"	v	file:
val2	tests/darray_tests.c	/^static int *val2 = NULL;$/;"	v	file:
value	src/lcthw/list.h	/^  void *value;$/;"	m	struct:ListNode
value	src/lcthw/radixmap.h	/^    uint32_t value;$/;"	m	struct:RMElement::__anon1
values	tests/list_algos_tests.c	/^char *values[]  = {"XXXX","1234","abcd","xjvef","NDSS"};$/;"	v
